### **简单介绍**
- HTTP(HyperText Transfer Protocol)是一套计算机网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户(如Web浏览器)能够从HTTP服务器(Web服务器)请求信息和服务，HTTP协议目前的版本是1.1。
- HTTP是一种无状态的协议，无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后web服务器返回相应(response)，连接就被关闭了，在服务器端不保留连接的相关信息。
- HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。
- HTTP使用内容类型，是指Web服务器向Web浏览器返回的文件都有与之相关的类型。所有这些类型在MIMEInternet邮件协议上模型化，即Web服务器告诉Web浏览器该文件所具有的种类，是HTML文档、GIF格式图像、声音文件还是独立的应用程序。大多数Web浏览器都拥有一系列的可配置的辅助应用程序，它们告诉浏览器应该如何处理Web服务器发送过来的各种内容类型。

# 1.http请求的过程
HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤:
#### 1.1 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称为TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行高层协议的连接。因此首先要建立TCP连接，一般TCP连接的端口是80。
#### 1.2 Web浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。
例如:GET/sample/hello.jsp HTTP/1.1
#### 1.3 Web浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
#### 1.4 Web服务器应答
客户机向服务器发出请求后，服务器会向客户机回送应答
HTTP/1.1 200 OK
应答的第一部分是协议的版本号和应答状态码
#### 1.5 Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于自己的数据及被请求的文档。
#### 1.6 Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此结束，接着，它就以Content-Type应答头信息所描述的歌会发送用户所请求的实际数据。
#### 1.7 Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码:Connection:keep-alive。TCP连接在发送后仍然保持打开的状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络的带宽。

# 2.HTTP请求格式
当浏览器向Web服务器发送请求时，它向服务器传递了一个数据款，也就是请求信息，HTTP请求信息由三部分组成:
1. 请求方法URI秀逸/版本
2. 请求头(Request Header)
3. 请求正文
## HTTP请求Sample:
```
GET/Sample.js HTTP/1.1
Accept:image/gif.image/jpeg./
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip，deflate
username=jinqiao&password=1234
```
## 2.1 请求方法URI协议/版本
请求的第一行是"方法URL协议/版本":GET/sample.jsp HTTP/1.1
以上代码中"GET"代表请求方法，"/sample.jsp"表示URI，"HTTP/1.1"代表协议和协议的版本。
根绝HTTP标准，HTTP请求可以试用多种请求方法。例如：HTTP1.1支持7中请求方法：
* GET
* POST
* HEAD
* OPTIONS
* PUT
* DELETE
* TARCE
>在Internet应用中，最常用的方法是GET和POST。
## 2.2 请求头(Request Header)
请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明服务器所用的语言，请求正文的长度等。
```
Accept:image/gif.image/jpeg./
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)
Accept-Encoding:gzip,deflate.
```
## 2.3 请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：
`username=jinqiao&password=1234`
*在以上的例子的HTTP请求中，请求的正文只有一行内容。当然，在实际应用中，HTTP请求正文可以包含更多的内容。*
HTTP应答与HTTP请求相似，HTTP相应也是3个部分组成的，分别是：
1. 协议状态版本代码描述
2. 响应头(Response Header)
3. 响应正文
HTTP相应的例子：
```
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112
```
# 2.http状态码的意义
一些常见的状态代码为：
200 - 服务器成功返回网页 
404 - 请求的网页不存在 
503 - 服务器暂时不可用 
## 1xx（临时响应）
> 用于表示临时响应并需要请求者执行操作才能继续的状态代码。

* 100（继续） 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。
* 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。
## 2xx（成功）
> 用于表示服务器已成功处理了请求的状态代码。  
 
* 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。 
* 201（已创建） 请求成功且服务器已创建了新的资源。 
* 202（已接受） 服务器已接受了请求，但尚未对其进行处理。 
* 203（非授权信息） 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 
* 204（无内容） 服务器成功处理了请求，但未返回任何内容。 
* 205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 
* 206（部分内容） 服务器成功处理了部分 GET 请求。
## 3xx（已重定向） 
> 要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。

* 300（多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。 
* 301（永久移动） 请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。 
* 302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。 
* 303（查看其他位置） 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 
* 304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。
* 如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。 
* 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 
* 307（临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。
## 4xx（请求错误） 
> 这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。 

* 400（错误请求） 服务器不理解请求的语法。 
* 401（未授权） 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。 
* 403（已禁止） 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码（您可在 Google 网站管理员工具中诊 断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。 
* 404（未找到） 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。
如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具" 诊断"标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。
如果您在 Googlebot 尝试抓取的网址上发现此状态（位于"诊断"标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。
* 405（方法禁用） 禁用请求中所指定的方法。 
* 406（不接受） 无法使用请求的内容特性来响应请求的网页。 
* 407（需要代理授权） 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 
* 408（请求超时） 服务器等候请求时超时。 
* 409（冲突） 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。 
* 410（已删除） 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。 
* 411（需要有效长度） 服务器不会接受包含无效内容长度标头字段的请求。 
* 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
* 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。 
* 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法进行处理。 
* 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 
* 416（请求范围不符合要求） 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。 
* 417（未满足期望值） 服务器未满足"期望"请求标头字段的要求。
## 5xx（服务器错误）
>这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

* 500（服务器内部错误） 服务器遇到错误，无法完成请求。 
* 501（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 
* 502（错误网关） 服务器作为网关或代理，从上游服务器收到了无效的响应。 
* 503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 
* 504（网关超时） 服务器作为网关或代理，未及时从上游服务器接收请求。 
* 505（HTTP 版本不受支持）
# 3.http头部信息
## HTTP 头部解释 
### 3.1 Accept：
告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。
### 3.2 Accept-Charset： 
浏览器申明自己接收的字符集 
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 （gzip，deflate） 
Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。
### 3.3 Accept-Ranges：
WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。
### 3.4 Age：
当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 
### 3.5 Authorization：
当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，该头部来回应自己的身份验证信息给WEB服务器。
### 3.6 Cache-Control：
请求：
no-cache（不要缓存的实体，要求现在从WEB服务器去取） 
max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象） 
max-stale：（可以接受过去的对象，但是过期时间必须小于max-stale 值） 
min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象） 
响应：
public(可以用 Cached 内容回应任何用户) 
private（只能用缓存内容回应先前请求该内容的那个用户） 
no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端） 
max-age：（本响应包含的对象的过期时间） 
ALL: no-store（不允许缓存）
### 3.7 Connection：
请求：
close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。 
keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。 
响应：
close（连接已经关闭）。 
keepalive（连接保持着，在等待本次连接的后续请求）。 
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。 
例如：Keep-Alive：300 
### 3.8 Content-Encoding：
WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。 
例如：Content-Encoding：gzip 
Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。 
Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。 
例如：Content-Length: 26012 
Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。 
例如：Content-Range: bytes 21010-47021/47022 
Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。 
例如：Content-Type：application/xml
### 3.9 ETag：
就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改， 所以，ETag 的作用跟 Last-Modified 的 作用差不多，主要供 WEB 服务器 判断一个对象是否改变了。 
比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给 WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。 
### 3.10 Expired：
WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。 
是 HTTP/1.0 的头部。 
例如：Expires：Sat, 23 May 2009 10:02:12 GMT 
### 3.11 Host：
客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。 
例如：Host：rss.sina.com.cn 
### 3.12 If-Match：
如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。 
If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。
### 3.13 If-Modified-Since：
如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。 
例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT 
If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行 
请求的动作（比如返回对象）。
### 3.14 If-Range：
浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。 浏览器通过发送请求对象的ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。 
总是跟 Range 头部一起使用。 
### 3.15 Last-Modified：
WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。 
例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT 
### 3.16 Location：
WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。 
例如：Location：http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif 
### 3.17 Pramga：
主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。 
例如：Pragma：no-cache 
### 3.18 Proxy-Authenticate： 
代理服务器响应浏览器，要求其提供代理身份验证信息。 
Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 
### 3.19 Range：
浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。 
例如：Range: bytes=1173546-
### 3.20 Referer：
浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。 
例如：Referer：http://www.sina.com/ 
### 3.21 Server: 
WEB 服务器表明自己是什么软件及版本等信息。 
例如：Server：Apache/2.0.61 (Unix) 
### 3.22 User-Agent: 
浏览器表明自己的身份（是哪种浏览器）。 
例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; 
rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14 
### 3.23 Transfer-Encoding: 
WEB 服务器表明自己对本响应消息体（不是消息体里面的对象） 
作了怎样的编码，比如是否分块（chunked）。 
例如：Transfer-Encoding: chunked 
### 3.24 Vary: 
WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。 
假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为： 
Content-Encoding: gzip; Vary: Content-Encoding 那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。 
例如：Vary：Accept-Encoding
### 3.25 Via： 
列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。 
当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via头部，并把自己的相关信息加到后面， 以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。 
例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13) 

# 4.cookie状态管理
> [WEB状态管理机制剖析（cookie、session）](http://blog.csdn.net/daijin888888/article/details/51133155)

# 5.方法Get Post
## GET方法
GET方法是默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送。
因此，如果使用GET方法来提交表单数据就存在着安全隐患。而且由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。
## POST方法
POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法客服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。
从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY_STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。
# 6.https
<http://www.cnblogs.com/wuhuacong/p/4814708.html>

> 更新测试V1.1